---
title: "Data visualisation"
---
<div style="width: 25%; position: absolute; top: 0; right: 0; padding-top: 1em;">
  <img src="images/x-all-the-things.png" alt="Visualise all the things" style="width:100%;" />
  Visualise all the things
</div>


```{r opts, echo = FALSE}
#suppress the warnings and other messages from showing in the knitted file.
knitr::opts_chunk$set(
  fig.width  = 8, 
  fig.height = 5, 
  fig.path   = 'images/02/',
  echo       = TRUE, 
  warning    = FALSE, 
  message    = FALSE
)
```

## Learning Objectives {.tabset}

### Basic

1. Understand what types of graphs are best for different types of data
    + 1 continuous
    + 1 categorical
    + 2 continuous
    + 1 categorical, 1 continuous
    + continuous bivariate
    + 3 continuous
2. Create common types of graphs with ggplot2
    + `geom_bar()`
    + `geom_density()`
    + `geom_histogram()`
    + `geom_violin()`
    + `geom_boxplot()`
    + `geom_col()`
    + `geom_point()`
    + `geom_smooth()`
3. Save plots as an image file
    
### Intermediate

4. Represent factorial designs with different colours or facets
5. Superimpose different types of graphs
6. Add lines to graphs
7. Create less common types of graphs
    + `geom_tile()`
    + `geom_density2d()`
    + `geom_bin2d()`
    + `geom_hex()`
8. Deal with overlapping data
9. Use the `viridis` package to set colours
10. Set custom labels

### Advanced

11. Arrange plots in a grid using `cowplot`
12. Adjust axes (e.g., flip coordinates, set axis limits)
13. Change the theme
14. Create interactive graphs with `plotly`


## Prep

* [Chapter 3: Data Visualisation](http://r4ds.had.co.nz/data-visualisation.html) of *R for Data Science*
* [Chapter 28: Graphics for communication](http://r4ds.had.co.nz/graphics-for-communication.html) of *R for Data Science*

## Resources

* [ggplot2 cheat sheet](https://www.rstudio.com/wp-content/uploads/2016/11/ggplot2-cheatsheet-2.1.pdf)
* [ggplot2 documentation](http://ggplot2.tidyverse.org/reference/)
* [The R Graph Gallery](http://www.r-graph-gallery.com/) (this is really useful)
* [Top 50 ggplot2 Visulaizations](http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html)
* [R Graphics Cookbook](http://www.cookbook-r.com/Graphs/) by Winston Chang
* [The viridis color palettes](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html)
* [ggplot extensions](https://www.ggplot2-exts.org/)
* [plotly](https://plot.ly/ggplot2/) for creating interactive graphs

## Examples

```{r}

# libraries needed for these graphs
library(tidyverse)
library(viridis)
library(plotly)

# cowplot will change the default theme of graphs, so we're loading it later
# library(cowplot) 

```

### Data

Here we've created some data frames with different types of data. 

* `pets` has a single column with 100 pet types
* `demog` has `height` and `age` for 500 men and 500 women.
* `x_vs_y` has two correlated continuous variables (`x` and `y`)
* `overlap` has two correlated ordinal variables and 1000 observations so there is a lot of overlap
* `overplot` has two correlated continuous variables and 10000 observations

First, think about what kinds of graphs are best for representing these different types of data.

```{r}

pets <- tibble(
  pet = sample(
    c("dog", "cat", "ferret", "bird", "fish"), 
    100, 
    TRUE, 
    c(0.45, 0.40, 0.05, 0.05, 0.05)
  )
)

demog <- tibble(
  sex = rep(c("male", "female"), each = 500),
  height = c(rnorm(500, 70, 4), rnorm(500, 65, 3.5)),
  age = rpois(1000, 3) + 20
)

x_vs_y <- tibble(
  x = rnorm(100),
  y = x + rnorm(100, 0, 0.5)
)

overlap <- tibble(
  x = rbinom(1000, 10, 0.5),
  y = x + rbinom(1000, 20, 0.5)
)

overplot <- tibble(
  x = rnorm(10000),
  y = x + rnorm(10000, 0, 0.5)
)

```

Common Variable Combinations:

* 1 continuous
* 1 categorical
* 2 continuous
* 1 categorical, 1 continuous
* continuous bivariate
* 3 continuous

<p class="alert alert-info">Before you read ahead, come up with an example of 
each type of variable combination and sketch the types of graphs that would 
best display these data.</p> 

### Bar plot

Bar plots are good for categorical data where you want to represent the count.

<<<<<<< HEAD
```{r barplot}
=======
```{r}
>>>>>>> de69f03c732a14b807f094521df682a208a2fb88
ggplot(pets, aes(pet)) +
  geom_bar()
```

### Density plot

Density plots are good for one continuous variable, but only if you have a fairly 
large number of observations.

```{r density}

ggplot(demog, aes(height)) +
  geom_density()

```

You can represent subsets of a variable by assigning the category variable to 
the argument `group`, `fill`, or `color`. 

```{r density-sex}

ggplot(demog, aes(height, fill = sex)) +
  geom_density(alpha = 0.5)

```

<p class="alert alert-info">Try changing the `alpha` argument to figure out what 
it does.</p>


### Frequency Polygons

If you don't want smoothed distributions, try `geom_freqpoly()`.

```{r freqpoly}

ggplot(demog, aes(height, color = sex)) +
  geom_freqpoly(binwidth = 1)
  
```

<p class="alert alert-info">Try changing the `binwidth` argument to 5 and 0.1. 
How do you figure out the right value? </p>

### Histogram

Histograms are also good for one continuous variable, and work well if you don't 
have many observations. Set the `binwidth` to control how wide each bar is.

```{r histogram}

ggplot(demog, aes(height)) +
  geom_histogram(binwidth = 1)
  
```

If you show grouped histograms, you also probably want to change the default 
`position` argument.

```{r histogram-sex}

ggplot(demog, aes(height, fill=sex)) +
  geom_histogram(binwidth = 1, alpha = 0.5, position = "dodge")
  
```

<p class="alert alert-info">Try changing the `position` argument to "identity", 
"fill", "dodge", and "stack".</p>

### Boxplot

Boxplots are great for representing the distribution of grouped continuous 
variables. They fix most of the problems with using barplots for continuous data.

```{r boxplot}

ggplot(demog, aes(sex, height, fill=sex)) +
  geom_boxplot(alpha = 0.5)

```

### Violin plot

Violin pots are like sideways, mirrored density plots. They give even more information 
than a boxplot about distribution and are especially useful when you have non-normal 
distributions.

```{r violin}

ggplot(demog, aes(sex, height, fill=sex)) +
  geom_violin(
    trim = FALSE,
    draw_quantiles = c(0.25, 0.5, 0.75), 
    alpha = 0.5
  )

```

<p class="alert alert-info">Try changing the numbers in the `draw_quantiles` 
argument.</p>

### Violinbox plot

To demonstrate the use of `facet_grid()` for factorial designs, I created a new 
column called `agegroup` to split the data into participants older than the 
meadian age or younger than the median age.

```{r violinbox}

demog %>%
  mutate(agegroup = ifelse(age<median(age), "Younger", "Older")) %>%
  ggplot(aes(sex, height, fill=sex)) +
    geom_violin(trim = FALSE, alpha=0.5, show.legend = FALSE) +
    geom_boxplot(width = 0.25, fill="white") +
    facet_grid(.~agegroup) +
    scale_fill_manual(values = c("orange", "green"))

```

<p class="alert alert-info">Set the `show.legend` argument to `FALSE` to hide the 
legend. We do this here because the x-axis already labels the sexes.</p>

### Violin-jitter plot

If you don't have a lot of data points, it's good to represent them individually. 
You can use `geom_point` to do this, setting `position` to "jitter".

```{r violin-jitter}

demog %>%
  sample_n(50) %>%  # choose 50 random observations from the dataset
  ggplot(aes(sex, height, fill=sex)) +
  geom_violin(
    trim = FALSE,
    draw_quantiles = c(0.25, 0.5, 0.75), 
    alpha=0.5
  ) + 
  geom_point(position = "jitter", alpha = 0.7, size = 3)

```

### Column plot

Column plots are the worst way to represent grouped continuous data, but also 
one of the most common.

To make column plots with error bars, you first need to calculate the means, 
error bar uper limits (`ymax`) and error bar lower limits (`ymin`) for each 
category. You'll learn more about how to use the code below in the next two lessons.

```{r colplot}

# calculate mean and SD for each sex
demog %>%
  group_by(sex) %>%
  summarise(
    mean = mean(height),
    sd = sd(height)
  ) %>%
ggplot(aes(sex, mean, fill=sex)) +
  geom_col(alpha = 0.5) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.25) +
  geom_hline(yintercept = 40)

```

<p class="alert alert-info">What do you think `geom_vline()` does?</p>

### Save as File

You can save a ggplot using `ggsave()`. It saves the last ggplot you made, 
by default, but you can specify which plot you want to save if you assigned that 
plot to a variable.

You can set the `width` and `height` of your plot. The default units are inches, 
but you can change the `units` argument to "in", "cm", or "mm".


```{r, eval = FALSE}

demog_box <- ggplot(demog, aes(sex, height, fill=sex)) +
  geom_boxplot(alpha = 0.5)

demog_violin <- ggplot(demog, aes(sex, height, fill=sex)) +
  geom_violin(alpha = 0.5)

ggsave("demog_violin_plot.png", width = 5, height = 7)

ggsave("demog_box_plot.jpg", plot = demog_box, width = 5, height = 7)

```

### Grid of plots

You can use the [ `cowplot`](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html) 
package to easily make grids of different graphs. First, you have to assign each 
plot a name. Then you list all the plots as the first arguments of `plot_grid()` 
and provide a list of labels.

```{r}

library(cowplot)

my_hist <- ggplot(demog, aes(height, fill=sex)) +
  geom_histogram(
    binwidth = 1, 
    alpha = 0.5, 
    position = "dodge", 
    show.legend = FALSE
  )

my_violin <- ggplot(demog, aes(sex, height, fill=sex)) +
  geom_violin(
    trim = FALSE,
    draw_quantiles = c(0.5), 
    alpha = 0.5, 
    show.legend = FALSE
  )

my_box <- ggplot(demog, aes(sex, height, fill=sex)) +
  geom_boxplot(alpha=0.5, show.legend = FALSE)

my_density <- ggplot(demog, aes(height, fill=sex)) +
  geom_density(alpha=0.5, show.legend = FALSE)

my_bar <- demog %>%
  group_by(sex) %>%
  summarise(
    mean = mean(height),
    sd = sd(height)
  ) %>%
ggplot(aes(sex, mean, fill=sex)) +
  geom_bar(stat="identity", alpha = 0.5, show.legend = FALSE) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.25)

plot_grid(
  my_violin, 
  my_box, 
  my_density, 
  my_bar, 
  labels = c("A", "B", "C", "D")
)

```

<p class="alert alert-info">Once you load the cowplot package, your ggplot 
default theme will change.</p>

### Scatter plot

Scatter plots are a good way to represent the relationship between two continuous variables.

```{r scatter}

ggplot(x_vs_y, aes(x, y)) +
  geom_point()

```

### Line graph

You often want to represent the relationship as a single line.

```{r line}
ggplot(x_vs_y, aes(x, y)) +
  geom_smooth(method="lm")
```

### Scatter-line graph

If your graph isn't too complicated, it's good to also show the individual data 
points behind the line.

```{r scatter_line}

ggplot(x_vs_y, aes(x, y)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method="lm")
  

```

### Overlapping Discrete Data

You can deal with overlapping data points (very common if you're using Likert scales) by reducing the opacity of the points. You need to use trial and error to adjust these so they look right.

```{r overlap_alpha}

ggplot(overlap, aes(x, y)) +
  geom_point(size = 5, alpha = .05) +
  geom_smooth(method="lm")

```

Alternatively, you can transform your data to create a count column and use the count to set the dot colour.

```{r overlap_colour}

overlap %>%
  group_by(x, y) %>%
  summarise(count = n()) %>%
  ggplot(aes(x, y, color=count)) +
  geom_point(size = 5) +
  scale_color_viridis()

```

Or you can set the size of the dot proportional to the number of overlapping observations.

```{r overlap_size}

overlap %>%
  group_by(x, y) %>%
  summarise(count = n()) %>%
  ggplot(aes(x, y, size=count)) +
  geom_point(colour = "#663399")

```

### Overlapping Continuous Data

Even if the variables are continuous, overplotting might obscure any relationships 
if you have lots of data.

```{r overplot-point}
overplot %>%
  ggplot(aes(x, y)) + 
  geom_point()
```

Use `geom_density2d()` to create a contour map.

```{r}
overplot %>%
  ggplot(aes(x, y)) + 
  geom_density2d()
```

Use `geom_bin2d()` to create a rectangular heatmap of bin counts. Set the 
`binwidth` to the x and y dimensions to capture in each box.

```{r}
overplot %>%
  ggplot(aes(x, y)) + 
  geom_bin2d(binwidth = c(1,1))
```

Use `geomhex()` to create a hexagonal heatmap of bin counts.
<span class="text-info">Adjust the `binwidth`, `xlim()`, `ylim()` and/or the
figure dimensions to make the hexagons more or less stretched.</span>

```{r overplot-hex, fig.width=6, fig.height=5}
overplot %>%
  ggplot(aes(x, y)) + 
  geom_hex(binwidth = c(0.25, 0.25))
```

### Heat map

I've included the code for creating a correlation matrix from a table of variables, 
but you don't need to understand how this is done yet. We'll cover `mutate` and 
`gather` functions in the `dplyr` and `tidyr` lessons.

```{r}
# generate two sets of correlated variables (a and b)
heatmap <- tibble(
  a1 = rnorm(100),
  b1 = rnorm(100)
) %>% 
mutate(
  a2 = a1 + rnorm(100),
  a3 = a1 + rnorm(100),
  a4 = a1 + rnorm(100),
  b2 = b1 + rnorm(100),
  b3 = b1 + rnorm(100),
  b4 = b1 + rnorm(100)
) %>%
cor() %>% # create the correlation matrix
as.data.frame() %>% # make it a data frame
rownames_to_column(var = "V1") %>% # set rownames as V1
gather("V2", "r", a1:b4) # wide to long (V2)
```

Once you have a correlation matrix in the correct (long) format, it's easy to 
make a heatmap using `geom_tile()`.

```{r heatmap}
ggplot(heatmap, aes(V1, V2, fill=r)) +
  geom_tile() +
  scale_fill_viridis()
```

<p class="alert alert-info">The file type is set from the filename suffix, or by 
specifying the argument `device`, which can take the following values: 
"eps", "ps", "tex", "pdf", "jpeg", "tiff", "png", "bmp", "svg" or "wmf".</p>

### Interactive Plots

You can use the `plotly` package to make interactive graphs. Just assign your 
ggplot to a variable and use the function `ggplotly()`.

```{r}

demog_plot <- ggplot(demog, aes(age, height, fill=sex)) +
  geom_point(position = position_jitter(width= 0.2, height = 0), size = 2)

ggplotly(demog_plot)

```

<p class="alert alert-info">Hover over the data points above and click on the 
legend items.</p>

## Exercises{.tabset .tabset-pills}

### Distribution

Generate a violin plot, boxplot, histogram, density plot, and barplot for the 
following data. Save each plot as a PNG file.

```{r}

# dog weights estimated from http://petobesityprevention.org/ideal-weight-ranges/

dogs <- tibble(
  breed = rep(c("beagle", "boxer", "bulldog"), each = 100),
  weight = c(
    rnorm(100, 24, 6),
    rnorm(100, 62.5, 12.5),
    rnorm(100, 45, 5)
  )
)

```

<div class="solution"><button>Violin Plot Solution</button>
```{r exercise-violin}
ggplot(dogs, aes(breed, weight, fill = breed)) +
  geom_violin(draw_quantiles = c(0.5), show.legend = FALSE)
```
</div>

<div class="solution"><button>Boxplot Solution</button>
```{r exercise-boxplot}
ggplot(dogs, aes(breed, weight, fill = breed)) +
  geom_boxplot(show.legend = FALSE)
```
</div>

<div class="solution"><button>Histogram Solution</button>
```{r exercise-histogram}
ggplot(dogs, aes(weight, fill = breed)) +
  geom_histogram(binwidth = 3, position = "dodge")
```
</div>

<div class="solution"><button>Density plot Solution</button>
```{r exercise-density}
ggplot(dogs, aes(weight, fill = breed)) +
  geom_density(alpha = 0.5) +
  xlim(0, 110)
```
</div>

<div class="solution"><button>Barplot Solution</button>
```{r exercise-barplot}
dogs %>%
  group_by(breed) %>%
  summarise(
    mean = mean(weight),
    sd = sd(weight)
  ) %>%
ggplot(aes(breed, mean, fill = breed)) +
  geom_bar(stat="identity", alpha = 0.5) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.25)
```
</div>

### Correlation

Represent the relationships among moral, sexual and pathogen disgust scores from 
the dataset [disgust_scores.csv](data/disgust_scores.csv). 

Make sure the graphs have appropriate titles and axis labels and that the range 
of the axes are the same in all graphs.

<div class="solution"><button>Solution</button>
```{r exercise-cor}

disgust <- read_csv("data/disgust_scores.csv")

ggplot(disgust, aes(moral, sexual)) +
  geom_smooth() +
  labs(title = "Moral vs Sexual Disgust") +
  xlim(0, 6) + ylim(0, 6)

ggplot(disgust, aes(moral, pathogen)) +
  geom_smooth() +
  labs(title = "Moral vs Pathogen Disgust") +
  xlim(0, 6) + ylim(0, 6)

ggplot(disgust, aes(pathogen, sexual)) +
  geom_smooth() +
  labs(title = "Pathogen vs Sexual Disgust") +
  xlim(0, 6) + ylim(0, 6)
  
```
</div>

### Many correlated variables

Create a heatmap of the relationships among all the questions in 
[disgust_cors.csv](data/disgust_cors.csv) 
(the correlations have already been calculated for you). 

<div class="solution"><button>Solution</button>
```{r exercise-heatmap}
read_csv("data/disgust_cors.csv") %>%
  ggplot(aes(V1, V2, fill=r)) +
  geom_tile() +
  scale_fill_viridis() +
  theme(axis.text.x = element_text(angle=90, hjust=1))
```
</div>
