---
title: "Data cleaning"
---

```{r opts, echo = FALSE}
#suppress the warnings and other messages from showing in the knitted file.
knitr::opts_chunk$set(
  fig.width  = 8, 
  fig.height = 5, 
  fig.path   = 'images/03/',
  echo       = TRUE, 
  warning    = FALSE, 
  message    = FALSE,
  cache      = TRUE
)
```

## Learning Objectives {.tabset}

### Basic

1. Understand the concept of "tidy data"
2. Be able to use the 4 basic `tidyr` verbs
    + [`gather()`](#gather)
    + [`separate()`](#separate)
    + [`spread()`](#spread)
    + [`unite()`](#unite)

### Intermediate

3. Be able to chain functions to load and tidy a dataset without creating several intermediate datasets
4. Be able to use arguments like [`sep`](#sep), [`extra`](#extra), and [`convert`](#convert) to handle less straightforward data cleaning

### Advanced

5. Be able to use [regular expressions](#regex) to separate complex columns


## Prep

* Read [Tidy Data](http://vita.had.co.nz/papers/tidy-data.html)


## Resources

* [Data wrangling cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)
* [Chapter 12: Tidy Data](http://r4ds.had.co.nz/tidy-data.html) in *R for Data Science*

## Examples

```{r, results = 'hide', warning = FALSE, message = FALSE}

# libraries needed for these graphs
library(tidyverse)
library(readxl)

```

### Load Data

Get data on infant mortality rates from the CSV file 
[`infmort.csv`](data/infmort.csv) in the directory `data`.

```{r}
infmort <- read_csv("data/infmort.csv")
glimpse(infmort)
```

Get data on maternal mortality from from the excel file 
[`matmort.xls`](data/matmort.xls) in the directory `data`

```{r}
matmort <- read_xls("data/matmort.xls")
glimpse(matmort)
```

Get data on country codes from [https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv](https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv)

```{r}
ccodes <- read_csv("https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv")
glimpse(ccodes)
```


### gather()

<a name="#gather"></a>
`gather(data, key = "key", value = "value", ..., na.rm = FALSE, convert = FALSE, factor_key = FALSE)`

`matmort` is in wide format, with a separate column for each year. Change it to 
long format, with a row for each County/Year observation.

* `key` is what you want to call the row headers; it's "year" in this example. 
* `value` is what you want to call the values in the gathered columns; they're "stats" in this example.
* The `...` refers to the columns you want to gather. You can refer to them by their names, like `col1, col2, col3, col4` or `col1:col4` or by their numbers, like `8, 9, 10` or `8:10`.
  
This example is complicated because the column names to gather _are_ numbers. 
If the column names are non-standard (e.g., have spaces, start with numbers, or 
have special characters), you can enclose them in backticks (\`) like the example below.

```{r}

matmort_long <- matmort %>%
  gather("Year", "stats", `1990`:`2015`)

glimpse(matmort_long)

```

### separate()

<a name="#separate"></a>
`separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE, convert = FALSE, extra = "warn", fill = "warn")`

The data in the `stats` column is in a crazy format with some sort of 
confidence interval in brackets and lots of extra spaces. We don't need 
any of the spaces, so first we'll remove them with `mutate`. 

The `separate` function will separate your data on anything that is not 
a number or letter, so try it first without specifying the `sep` argument. 
The `into` argument is a list of the new column names.

```{r}

matmort_split <- matmort_long %>%
  mutate(stats = gsub(" ", "", stats)) %>%
  separate(stats, c("rate", "ci_low", "ci_hi"))

glimpse(matmort_split)

```

<p class="alert alert-info">The `gsub(pattern, replacement, x)` function is a 
flexible way to do search and replace. The example above replaces all occurances 
of the `pattern` " " (a space), with the `replacement` "" (nothing), in the 
string `x` (the `stats` column). Use `sub()` instead if you only want to replace 
the first occurance of a pattern. We only used a simple pattern here, but you 
can use more complicated [regex](https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html) 
patterns to replace, for example, all even numbers 
(e.g., `gsub("[:02468:]", "*", "id = 123456")`) or all occurances of 
the word colour in US or UK spelling 
(e.g., `gsub("colo(u)?r", "***", "replace color, colour, or colours, but not collors")`).</p>

#### Handle spare columns with `extra`

<a name="#extra"></a>
<p class="alert alert-warning">The previous example should have given you an error warning about 
"Too many values at 543 locations". This is because `separate` splits the column 
at the brackets and dashes, so the text "100[90-110]" would split into four values 
c("100", "90", "110", ""), but we only specified 3 new columns. The fourth value 
is always empty (just the part after the last bracket), so we are happy to drop 
it, but `separate` generates a warning so you don't do that accidentally. You can 
turn off the warning by adding the `extra` argument and setting it to "drop". 
Look at the help for `??tidyr::separate` to see what the other options do.</p>


```{r}

matmort_split <- matmort_long %>%
  mutate(stats = gsub(" ", "", stats)) %>%
  separate(stats, c("rate", "ci_low", "ci_hi"), extra = "drop")

glimpse(matmort_split)

```

#### Set delimiters with `sep`

<a name="#sep"></a>
Now do the same with `infmort`. It's already in long format, so you don't need 
to use `gather`, but the third column has a crazy long name, so we can just 
refer to it by its column number (3).

```{r}

infmort_split <- infmort %>%
  separate(3, c("rate", "ci_low", "ci_hi"), extra = "drop")

glimpse(infmort_split)

```

*Wait, that didn't work at all!* It split the column on spaces, brackets, _and_ 
full stops. We just want to split on the spaces, brackets and dashes. So we need 
to manually set `sep` to what the delimiters are. Also, once there are more than 
a few arguments specified for a function, it's easier to read them if you put 
one argument on each line.

<a name="#regex"></a>
<p class="alert alert-warning">You can use [regular expressions](https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html) 
to separate complex columns. Here, we want to separate on dashes and brackets. 
You can separate on a list of delimiters by putting them in parentheses, separated 
by "|". It's a little more complicated because brackets have a special meaning 
in regex, so you need to "escape" the left one with two backslashes "\\\\".</p>

```{r}

infmort_split <- infmort %>%
  separate(
    col = 3, 
    into = c("rate", "ci_low", "ci_hi"), 
    extra = "drop", 
    sep = "(\\[|-|])"
  )

glimpse(infmort_split)

```

#### Fix data types with `convert`

<a name="#convert"></a>
That's better. Notice the _<chr>_ next to `Year`, `rate`, `ci_low` and `ci_hi`. 
That means these columns hold characters (like words), not numbers or integers. 
This can cause problems when you try to do thigs like average the numbers (you 
can't average words), so we can fix it by adding the argument `convert` and 
setting it to `TRUE`.

```{r}

infmort_split <- infmort %>%
  separate(3, c("rate", "ci_low", "ci_hi"), extra = "drop", sep = "(\\[|-|])", convert = TRUE)

glimpse(infmort_split)
  
```

Do the same for `matmort`.

```{r}

matmort_split <- matmort_long %>%
  mutate(stats = gsub(" ", "", stats)) %>%
  separate(stats, c("rate", "ci_low", "ci_hi"), extra = "drop", convert = TRUE)

glimpse(matmort_split)

```

#### All in one step

We can chain all the steps above together, since we don't need those intermediate dataframes.

```{r}

infmort <- read_csv("data/infmort.csv") %>%
  separate(
    3, 
    c("rate", "ci_low", "ci_hi"), 
    extra = "drop", 
    sep = "(\\[|-|])", 
    convert = TRUE
  )

matmort <- read_xls("data/matmort.xls") %>%
  gather("Year", "stats", `1990`:`2015`) %>%
  mutate(stats = gsub(" ", "", stats)) %>%
  separate(
    stats, 
    c("rate", "ci_low", "ci_hi"), 
    extra = "drop", 
    convert = TRUE
  )

glimpse(matmort)
glimpse(infmort)

```


### spread()

<a name="#spread"></a>
`spread(data, key, value, fill = NA, convert = FALSE, drop = TRUE, sep = NULL)`

You can reverse the processes above, as well. For example, you can convert data 
from long format into wide format.

* `key` is the column that contains your new column headers
* `value` is the column that contains the values in the new spread columns

Let's spread out the infant mortality rate by year.

```{r}

infmort_wide <- infmort %>%
  spread(Year, rate)

glimpse(infmort_wide)

```

<p class="alert alert-warning">Nope, that didn't work at all, but it's a really common mistake when spreading 
data. This is because `spread` matches on all the remaining columns, so 
Afghanistan with `ci_low` of 52.7 is treated as a different observation than 
Afghanistan with `ci_low` of 55.7. We can fix this by merging the 
`rate`, `ci_low` and `ci_hi` columns back together.</p>

### unite()

<a name="#unite"></a>
`unite(data, col, ..., sep = "_", remove = TRUE)`

```{r}

infmort_united <- infmort %>%
  unite(rate_ci, rate, ci_low, ci_hi)

glimpse(infmort_united)

```


#### Control separation with `sep`

`unite()` separates merged names with an underscore by default. 
Set the `sep` argument if you want to change that.

```{r}

infmort_united <- infmort %>%
  unite(rate_ci, rate, ci_low, ci_hi, sep = ", ")

glimpse(infmort_united)

```

<p class="alert alert-info">What if you want to put it back into the format "rate [ci_low - ci_hi]"? 
Then, `mutate` and `paste` are a better choice than `unite`, but you have to get 
rid of the `rate`, `ci_low` and `ci_hi` columns with `select`. You'll learn more 
about these function in the [Data Manipulation](04_dplyr.html) lesson.</p>

```{r}

infmort_united <- infmort %>%
  mutate(rate_ci = paste0(rate, " [", ci_low, " - ", ci_hi, "]"))

glimpse(infmort_united)

```


Now let's try spreading on year again. Notice here we're uniting columns 
`rate:ci_hi`, instead of `rate, ci_low, ci_hi`. The colon just says to select 
all the columns between the first and last named ones. Check the help 
documentation for `??tidyr::unite` and `??tidyr::select` to see other ways to 
select columns.

```{r}

infmort_wide <- infmort %>%
  unite(rate_ci, rate:ci_hi, sep = ", ") %>%
  spread(Year, rate_ci)

glimpse(infmort_wide)

```


## Exercises

Tidy the data from [personality.csv](data/personality.csv).

These data are from a 5-factor (OCEAN) personality questionnaire. Each question 
is labelled with the domain (Op = openness, Co = concientiousness, Ex = extraversion, 
Ag = agreeableness, and Ne = neuroticism) and the question number.

1. Load the data and convert from wide to long format. 

    The resulting dataframe should have the columns: `user_id`, `date`, `question`, and `score`.

    <div class="solution"><button>Solution</button>
    ```{r}
    ocean <- read_csv("data/personality.csv") %>%
      gather("question", "score", Op1:Ex9)
    ```
    </div>

2. Split the `question` column into two columns: `domain` and `qnumber`.

    <p class="alert alert-info'>
    There is no character to split on, here, but you can separate a column after a 
    specific number of characters by setting `sep` to  an integer. For example, to 
    split "abcde" after the third character, use `sep = 3`, which results in 
    c("abc", "de"). You can also use negative number to split before the *n*th 
    character from the right. For example, to split a column that has words of 
    various lengths and 2-digit suffixes (like "lisa03"", "amanda38"), you can 
    use `sep = -2`.</p>

    <div class="solution"><button>Solution</button>
    ```{r}
    ocean_sep <- ocean %>%
      separate(question, c("domain", "qnumber"), sep = 2)
    ```
    </div>

3. Put the domain and qnumber columns back together into a new column named `domain_n`. Make it in a format like "Op_Q1".

    <div class="solution"><button>Solution</button>
    ```{r}
    ocean_unite <- ocean_sep %>%
      unite("domain_n", domain, qnumber, sep = "_Q")
    ```
    </div>

4. Convert back to wide format.

    <div class="solution"><button>Solution</button>
    ```{r}
    ocean_spread <- ocean_unite %>%
      spread(domain_n, score)
    ```
    </div>
    
5. Load the dataset [family_composition.csv](data/family_composition.csv).

    The columns `oldbro` through `twinsis` give the number of sibling of that 
    age and sex. Put this into long format.

    <div class="solution"><button>Solution</button>
    ```{r, message = FALSE}
    
    family <- read_csv("data/family_composition.csv") %>%
      gather("sibtype", "n", oldbro:twinsis) %>%
      separate(sibtype, c("sibage", "sibsex"), sep = -4)
    
    ```
    </div>
    
6. Calculcate how many siblings of each sex each person has, narrow the dataset down to people with fewer than 6 siblings, and generate at least two different ways to graph this.

    <div class="solution"><button>Solution</button>
    ```{r exercise-sibs1}
    
    family %>%
      group_by(user_id, sex, sibsex) %>%
      summarise(n = sum(n)) %>%
      group_by(user_id) %>%
      filter(sex %in% c("male", "female"), sum(n) < 6) %>%
      ggplot(aes(n, fill = sibsex)) +
      geom_histogram(binwidth = 1, colour = "black", position = "dodge")
    
    ```
    
    ```{r exercise-sibs2}
    family %>%
      group_by(user_id, sex, sibsex) %>%
      summarise(n = sum(n)) %>%
      filter(sex %in% c("male", "female")) %>%
      spread(sibsex, n) %>%
      filter(bro + sis < 6) %>%
      ggplot(aes(bro, sis)) +
      geom_bin2d(binwidth = c(1,1)) +
      scale_fill_viridis()
    ```    
    </div>

